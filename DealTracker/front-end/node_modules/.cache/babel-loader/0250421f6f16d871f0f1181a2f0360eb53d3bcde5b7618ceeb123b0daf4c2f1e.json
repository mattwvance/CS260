{"ast":null,"code":"import _regeneratorRuntime from \"/home/ubuntu/environment/public_html/DealTracker/front-end/node_modules/@babel/runtime/helpers/esm/regeneratorRuntime.js\";\nimport _asyncToGenerator from \"/home/ubuntu/environment/public_html/DealTracker/front-end/node_modules/@babel/runtime/helpers/esm/asyncToGenerator.js\";\nimport _classCallCheck from \"/home/ubuntu/environment/public_html/DealTracker/front-end/node_modules/@babel/runtime/helpers/esm/classCallCheck.js\";\nimport _createClass from \"/home/ubuntu/environment/public_html/DealTracker/front-end/node_modules/@babel/runtime/helpers/esm/createClass.js\";\nimport _asyncIterator from \"/home/ubuntu/environment/public_html/DealTracker/front-end/node_modules/@babel/runtime/helpers/esm/asyncIterator.js\";\nimport { File } from 'fetch-blob/from.js';\nimport { FormData } from 'formdata-polyfill/esm.min.js';\nvar s = 0;\nvar S = {\n  START_BOUNDARY: s++,\n  HEADER_FIELD_START: s++,\n  HEADER_FIELD: s++,\n  HEADER_VALUE_START: s++,\n  HEADER_VALUE: s++,\n  HEADER_VALUE_ALMOST_DONE: s++,\n  HEADERS_ALMOST_DONE: s++,\n  PART_DATA_START: s++,\n  PART_DATA: s++,\n  END: s++\n};\nvar f = 1;\nvar F = {\n  PART_BOUNDARY: f,\n  LAST_BOUNDARY: f *= 2\n};\nvar LF = 10;\nvar CR = 13;\nvar SPACE = 32;\nvar HYPHEN = 45;\nvar COLON = 58;\nvar A = 97;\nvar Z = 122;\nvar lower = function lower(c) {\n  return c | 0x20;\n};\nvar noop = function noop() {};\nvar MultipartParser = /*#__PURE__*/function () {\n  /**\n   * @param {string} boundary\n   */\n  function MultipartParser(boundary) {\n    _classCallCheck(this, MultipartParser);\n    this.index = 0;\n    this.flags = 0;\n    this.onHeaderEnd = noop;\n    this.onHeaderField = noop;\n    this.onHeadersEnd = noop;\n    this.onHeaderValue = noop;\n    this.onPartBegin = noop;\n    this.onPartData = noop;\n    this.onPartEnd = noop;\n    this.boundaryChars = {};\n    boundary = '\\r\\n--' + boundary;\n    var ui8a = new Uint8Array(boundary.length);\n    for (var i = 0; i < boundary.length; i++) {\n      ui8a[i] = boundary.charCodeAt(i);\n      this.boundaryChars[ui8a[i]] = true;\n    }\n    this.boundary = ui8a;\n    this.lookbehind = new Uint8Array(this.boundary.length + 8);\n    this.state = S.START_BOUNDARY;\n  }\n\n  /**\n   * @param {Uint8Array} data\n   */\n  _createClass(MultipartParser, [{\n    key: \"write\",\n    value: function write(data) {\n      var _this = this;\n      var i = 0;\n      var length_ = data.length;\n      var previousIndex = this.index;\n      var lookbehind = this.lookbehind,\n        boundary = this.boundary,\n        boundaryChars = this.boundaryChars,\n        index = this.index,\n        state = this.state,\n        flags = this.flags;\n      var boundaryLength = this.boundary.length;\n      var boundaryEnd = boundaryLength - 1;\n      var bufferLength = data.length;\n      var c;\n      var cl;\n      var mark = function mark(name) {\n        _this[name + 'Mark'] = i;\n      };\n      var clear = function clear(name) {\n        delete _this[name + 'Mark'];\n      };\n      var callback = function callback(callbackSymbol, start, end, ui8a) {\n        if (start === undefined || start !== end) {\n          _this[callbackSymbol](ui8a && ui8a.subarray(start, end));\n        }\n      };\n      var dataCallback = function dataCallback(name, clear) {\n        var markSymbol = name + 'Mark';\n        if (!(markSymbol in _this)) {\n          return;\n        }\n        if (clear) {\n          callback(name, _this[markSymbol], i, data);\n          delete _this[markSymbol];\n        } else {\n          callback(name, _this[markSymbol], data.length, data);\n          _this[markSymbol] = 0;\n        }\n      };\n      for (i = 0; i < length_; i++) {\n        c = data[i];\n        switch (state) {\n          case S.START_BOUNDARY:\n            if (index === boundary.length - 2) {\n              if (c === HYPHEN) {\n                flags |= F.LAST_BOUNDARY;\n              } else if (c !== CR) {\n                return;\n              }\n              index++;\n              break;\n            } else if (index - 1 === boundary.length - 2) {\n              if (flags & F.LAST_BOUNDARY && c === HYPHEN) {\n                state = S.END;\n                flags = 0;\n              } else if (!(flags & F.LAST_BOUNDARY) && c === LF) {\n                index = 0;\n                callback('onPartBegin');\n                state = S.HEADER_FIELD_START;\n              } else {\n                return;\n              }\n              break;\n            }\n            if (c !== boundary[index + 2]) {\n              index = -2;\n            }\n            if (c === boundary[index + 2]) {\n              index++;\n            }\n            break;\n          case S.HEADER_FIELD_START:\n            state = S.HEADER_FIELD;\n            mark('onHeaderField');\n            index = 0;\n          // falls through\n          case S.HEADER_FIELD:\n            if (c === CR) {\n              clear('onHeaderField');\n              state = S.HEADERS_ALMOST_DONE;\n              break;\n            }\n            index++;\n            if (c === HYPHEN) {\n              break;\n            }\n            if (c === COLON) {\n              if (index === 1) {\n                // empty header field\n                return;\n              }\n              dataCallback('onHeaderField', true);\n              state = S.HEADER_VALUE_START;\n              break;\n            }\n            cl = lower(c);\n            if (cl < A || cl > Z) {\n              return;\n            }\n            break;\n          case S.HEADER_VALUE_START:\n            if (c === SPACE) {\n              break;\n            }\n            mark('onHeaderValue');\n            state = S.HEADER_VALUE;\n          // falls through\n          case S.HEADER_VALUE:\n            if (c === CR) {\n              dataCallback('onHeaderValue', true);\n              callback('onHeaderEnd');\n              state = S.HEADER_VALUE_ALMOST_DONE;\n            }\n            break;\n          case S.HEADER_VALUE_ALMOST_DONE:\n            if (c !== LF) {\n              return;\n            }\n            state = S.HEADER_FIELD_START;\n            break;\n          case S.HEADERS_ALMOST_DONE:\n            if (c !== LF) {\n              return;\n            }\n            callback('onHeadersEnd');\n            state = S.PART_DATA_START;\n            break;\n          case S.PART_DATA_START:\n            state = S.PART_DATA;\n            mark('onPartData');\n          // falls through\n          case S.PART_DATA:\n            previousIndex = index;\n            if (index === 0) {\n              // boyer-moore derrived algorithm to safely skip non-boundary data\n              i += boundaryEnd;\n              while (i < bufferLength && !(data[i] in boundaryChars)) {\n                i += boundaryLength;\n              }\n              i -= boundaryEnd;\n              c = data[i];\n            }\n            if (index < boundary.length) {\n              if (boundary[index] === c) {\n                if (index === 0) {\n                  dataCallback('onPartData', true);\n                }\n                index++;\n              } else {\n                index = 0;\n              }\n            } else if (index === boundary.length) {\n              index++;\n              if (c === CR) {\n                // CR = part boundary\n                flags |= F.PART_BOUNDARY;\n              } else if (c === HYPHEN) {\n                // HYPHEN = end boundary\n                flags |= F.LAST_BOUNDARY;\n              } else {\n                index = 0;\n              }\n            } else if (index - 1 === boundary.length) {\n              if (flags & F.PART_BOUNDARY) {\n                index = 0;\n                if (c === LF) {\n                  // unset the PART_BOUNDARY flag\n                  flags &= ~F.PART_BOUNDARY;\n                  callback('onPartEnd');\n                  callback('onPartBegin');\n                  state = S.HEADER_FIELD_START;\n                  break;\n                }\n              } else if (flags & F.LAST_BOUNDARY) {\n                if (c === HYPHEN) {\n                  callback('onPartEnd');\n                  state = S.END;\n                  flags = 0;\n                } else {\n                  index = 0;\n                }\n              } else {\n                index = 0;\n              }\n            }\n            if (index > 0) {\n              // when matching a possible boundary, keep a lookbehind reference\n              // in case it turns out to be a false lead\n              lookbehind[index - 1] = c;\n            } else if (previousIndex > 0) {\n              // if our boundary turned out to be rubbish, the captured lookbehind\n              // belongs to partData\n              var _lookbehind = new Uint8Array(lookbehind.buffer, lookbehind.byteOffset, lookbehind.byteLength);\n              callback('onPartData', 0, previousIndex, _lookbehind);\n              previousIndex = 0;\n              mark('onPartData');\n\n              // reconsider the current character even so it interrupted the sequence\n              // it could be the beginning of a new sequence\n              i--;\n            }\n            break;\n          case S.END:\n            break;\n          default:\n            throw new Error(\"Unexpected state entered: \".concat(state));\n        }\n      }\n      dataCallback('onHeaderField');\n      dataCallback('onHeaderValue');\n      dataCallback('onPartData');\n\n      // Update properties for the next call\n      this.index = index;\n      this.state = state;\n      this.flags = flags;\n    }\n  }, {\n    key: \"end\",\n    value: function end() {\n      if (this.state === S.HEADER_FIELD_START && this.index === 0 || this.state === S.PART_DATA && this.index === this.boundary.length) {\n        this.onPartEnd();\n      } else if (this.state !== S.END) {\n        throw new Error('MultipartParser.end(): stream ended unexpectedly');\n      }\n    }\n  }]);\n  return MultipartParser;\n}();\nfunction _fileName(headerValue) {\n  // matches either a quoted-string or a token (RFC 2616 section 19.5.1)\n  var m = headerValue.match(/\\bfilename=(\"(.*?)\"|([^()<>@,;:\\\\\"/[\\]?={}\\s\\t]+))($|;\\s)/i);\n  if (!m) {\n    return;\n  }\n  var match = m[2] || m[3] || '';\n  var filename = match.slice(match.lastIndexOf('\\\\') + 1);\n  filename = filename.replace(/%22/g, '\"');\n  filename = filename.replace(/&#(\\d{4});/g, function (m, code) {\n    return String.fromCharCode(code);\n  });\n  return filename;\n}\nexport function toFormData(_x, _x2) {\n  return _toFormData.apply(this, arguments);\n}\nfunction _toFormData() {\n  _toFormData = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee(Body, ct) {\n    var m, parser, headerField, headerValue, entryValue, entryName, contentType, filename, entryChunks, formData, onPartData, appendToFile, appendFileToFormData, appendEntryToFormData, decoder, _iteratorAbruptCompletion, _didIteratorError, _iteratorError, _iterator, _step, chunk;\n    return _regeneratorRuntime().wrap(function _callee$(_context) {\n      while (1) {\n        switch (_context.prev = _context.next) {\n          case 0:\n            if (/multipart/i.test(ct)) {\n              _context.next = 2;\n              break;\n            }\n            throw new TypeError('Failed to fetch');\n          case 2:\n            m = ct.match(/boundary=(?:\"([^\"]+)\"|([^;]+))/i);\n            if (m) {\n              _context.next = 5;\n              break;\n            }\n            throw new TypeError('no or bad content-type header, no multipart boundary');\n          case 5:\n            parser = new MultipartParser(m[1] || m[2]);\n            entryChunks = [];\n            formData = new FormData();\n            onPartData = function onPartData(ui8a) {\n              entryValue += decoder.decode(ui8a, {\n                stream: true\n              });\n            };\n            appendToFile = function appendToFile(ui8a) {\n              entryChunks.push(ui8a);\n            };\n            appendFileToFormData = function appendFileToFormData() {\n              var file = new File(entryChunks, filename, {\n                type: contentType\n              });\n              formData.append(entryName, file);\n            };\n            appendEntryToFormData = function appendEntryToFormData() {\n              formData.append(entryName, entryValue);\n            };\n            decoder = new TextDecoder('utf-8');\n            decoder.decode();\n            parser.onPartBegin = function () {\n              parser.onPartData = onPartData;\n              parser.onPartEnd = appendEntryToFormData;\n              headerField = '';\n              headerValue = '';\n              entryValue = '';\n              entryName = '';\n              contentType = '';\n              filename = null;\n              entryChunks.length = 0;\n            };\n            parser.onHeaderField = function (ui8a) {\n              headerField += decoder.decode(ui8a, {\n                stream: true\n              });\n            };\n            parser.onHeaderValue = function (ui8a) {\n              headerValue += decoder.decode(ui8a, {\n                stream: true\n              });\n            };\n            parser.onHeaderEnd = function () {\n              headerValue += decoder.decode();\n              headerField = headerField.toLowerCase();\n              if (headerField === 'content-disposition') {\n                // matches either a quoted-string or a token (RFC 2616 section 19.5.1)\n                var _m = headerValue.match(/\\bname=(\"([^\"]*)\"|([^()<>@,;:\\\\\"/[\\]?={}\\s\\t]+))/i);\n                if (_m) {\n                  entryName = _m[2] || _m[3] || '';\n                }\n                filename = _fileName(headerValue);\n                if (filename) {\n                  parser.onPartData = appendToFile;\n                  parser.onPartEnd = appendFileToFormData;\n                }\n              } else if (headerField === 'content-type') {\n                contentType = headerValue;\n              }\n              headerValue = '';\n              headerField = '';\n            };\n            _iteratorAbruptCompletion = false;\n            _didIteratorError = false;\n            _context.prev = 20;\n            _iterator = _asyncIterator(Body);\n          case 22:\n            _context.next = 24;\n            return _iterator.next();\n          case 24:\n            if (!(_iteratorAbruptCompletion = !(_step = _context.sent).done)) {\n              _context.next = 30;\n              break;\n            }\n            chunk = _step.value;\n            parser.write(chunk);\n          case 27:\n            _iteratorAbruptCompletion = false;\n            _context.next = 22;\n            break;\n          case 30:\n            _context.next = 36;\n            break;\n          case 32:\n            _context.prev = 32;\n            _context.t0 = _context[\"catch\"](20);\n            _didIteratorError = true;\n            _iteratorError = _context.t0;\n          case 36:\n            _context.prev = 36;\n            _context.prev = 37;\n            if (!(_iteratorAbruptCompletion && _iterator.return != null)) {\n              _context.next = 41;\n              break;\n            }\n            _context.next = 41;\n            return _iterator.return();\n          case 41:\n            _context.prev = 41;\n            if (!_didIteratorError) {\n              _context.next = 44;\n              break;\n            }\n            throw _iteratorError;\n          case 44:\n            return _context.finish(41);\n          case 45:\n            return _context.finish(36);\n          case 46:\n            parser.end();\n            return _context.abrupt(\"return\", formData);\n          case 48:\n          case \"end\":\n            return _context.stop();\n        }\n      }\n    }, _callee, null, [[20, 32, 36, 46], [37,, 41, 45]]);\n  }));\n  return _toFormData.apply(this, arguments);\n}","map":{"version":3,"names":["File","FormData","s","S","START_BOUNDARY","HEADER_FIELD_START","HEADER_FIELD","HEADER_VALUE_START","HEADER_VALUE","HEADER_VALUE_ALMOST_DONE","HEADERS_ALMOST_DONE","PART_DATA_START","PART_DATA","END","f","F","PART_BOUNDARY","LAST_BOUNDARY","LF","CR","SPACE","HYPHEN","COLON","A","Z","lower","c","noop","MultipartParser","boundary","index","flags","onHeaderEnd","onHeaderField","onHeadersEnd","onHeaderValue","onPartBegin","onPartData","onPartEnd","boundaryChars","ui8a","Uint8Array","length","i","charCodeAt","lookbehind","state","data","length_","previousIndex","boundaryLength","boundaryEnd","bufferLength","cl","mark","name","clear","callback","callbackSymbol","start","end","undefined","subarray","dataCallback","markSymbol","_lookbehind","buffer","byteOffset","byteLength","Error","_fileName","headerValue","m","match","filename","slice","lastIndexOf","replace","code","String","fromCharCode","toFormData","Body","ct","test","TypeError","parser","entryChunks","formData","entryValue","decoder","decode","stream","appendToFile","push","appendFileToFormData","file","type","contentType","append","entryName","appendEntryToFormData","TextDecoder","headerField","toLowerCase","chunk","write"],"sources":["/home/ubuntu/environment/public_html/DealTracker/front-end/node_modules/node-fetch/src/utils/multipart-parser.js"],"sourcesContent":["import {File} from 'fetch-blob/from.js';\nimport {FormData} from 'formdata-polyfill/esm.min.js';\n\nlet s = 0;\nconst S = {\n\tSTART_BOUNDARY: s++,\n\tHEADER_FIELD_START: s++,\n\tHEADER_FIELD: s++,\n\tHEADER_VALUE_START: s++,\n\tHEADER_VALUE: s++,\n\tHEADER_VALUE_ALMOST_DONE: s++,\n\tHEADERS_ALMOST_DONE: s++,\n\tPART_DATA_START: s++,\n\tPART_DATA: s++,\n\tEND: s++\n};\n\nlet f = 1;\nconst F = {\n\tPART_BOUNDARY: f,\n\tLAST_BOUNDARY: f *= 2\n};\n\nconst LF = 10;\nconst CR = 13;\nconst SPACE = 32;\nconst HYPHEN = 45;\nconst COLON = 58;\nconst A = 97;\nconst Z = 122;\n\nconst lower = c => c | 0x20;\n\nconst noop = () => {};\n\nclass MultipartParser {\n\t/**\n\t * @param {string} boundary\n\t */\n\tconstructor(boundary) {\n\t\tthis.index = 0;\n\t\tthis.flags = 0;\n\n\t\tthis.onHeaderEnd = noop;\n\t\tthis.onHeaderField = noop;\n\t\tthis.onHeadersEnd = noop;\n\t\tthis.onHeaderValue = noop;\n\t\tthis.onPartBegin = noop;\n\t\tthis.onPartData = noop;\n\t\tthis.onPartEnd = noop;\n\n\t\tthis.boundaryChars = {};\n\n\t\tboundary = '\\r\\n--' + boundary;\n\t\tconst ui8a = new Uint8Array(boundary.length);\n\t\tfor (let i = 0; i < boundary.length; i++) {\n\t\t\tui8a[i] = boundary.charCodeAt(i);\n\t\t\tthis.boundaryChars[ui8a[i]] = true;\n\t\t}\n\n\t\tthis.boundary = ui8a;\n\t\tthis.lookbehind = new Uint8Array(this.boundary.length + 8);\n\t\tthis.state = S.START_BOUNDARY;\n\t}\n\n\t/**\n\t * @param {Uint8Array} data\n\t */\n\twrite(data) {\n\t\tlet i = 0;\n\t\tconst length_ = data.length;\n\t\tlet previousIndex = this.index;\n\t\tlet {lookbehind, boundary, boundaryChars, index, state, flags} = this;\n\t\tconst boundaryLength = this.boundary.length;\n\t\tconst boundaryEnd = boundaryLength - 1;\n\t\tconst bufferLength = data.length;\n\t\tlet c;\n\t\tlet cl;\n\n\t\tconst mark = name => {\n\t\t\tthis[name + 'Mark'] = i;\n\t\t};\n\n\t\tconst clear = name => {\n\t\t\tdelete this[name + 'Mark'];\n\t\t};\n\n\t\tconst callback = (callbackSymbol, start, end, ui8a) => {\n\t\t\tif (start === undefined || start !== end) {\n\t\t\t\tthis[callbackSymbol](ui8a && ui8a.subarray(start, end));\n\t\t\t}\n\t\t};\n\n\t\tconst dataCallback = (name, clear) => {\n\t\t\tconst markSymbol = name + 'Mark';\n\t\t\tif (!(markSymbol in this)) {\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tif (clear) {\n\t\t\t\tcallback(name, this[markSymbol], i, data);\n\t\t\t\tdelete this[markSymbol];\n\t\t\t} else {\n\t\t\t\tcallback(name, this[markSymbol], data.length, data);\n\t\t\t\tthis[markSymbol] = 0;\n\t\t\t}\n\t\t};\n\n\t\tfor (i = 0; i < length_; i++) {\n\t\t\tc = data[i];\n\n\t\t\tswitch (state) {\n\t\t\t\tcase S.START_BOUNDARY:\n\t\t\t\t\tif (index === boundary.length - 2) {\n\t\t\t\t\t\tif (c === HYPHEN) {\n\t\t\t\t\t\t\tflags |= F.LAST_BOUNDARY;\n\t\t\t\t\t\t} else if (c !== CR) {\n\t\t\t\t\t\t\treturn;\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tindex++;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t} else if (index - 1 === boundary.length - 2) {\n\t\t\t\t\t\tif (flags & F.LAST_BOUNDARY && c === HYPHEN) {\n\t\t\t\t\t\t\tstate = S.END;\n\t\t\t\t\t\t\tflags = 0;\n\t\t\t\t\t\t} else if (!(flags & F.LAST_BOUNDARY) && c === LF) {\n\t\t\t\t\t\t\tindex = 0;\n\t\t\t\t\t\t\tcallback('onPartBegin');\n\t\t\t\t\t\t\tstate = S.HEADER_FIELD_START;\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\treturn;\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\n\t\t\t\t\tif (c !== boundary[index + 2]) {\n\t\t\t\t\t\tindex = -2;\n\t\t\t\t\t}\n\n\t\t\t\t\tif (c === boundary[index + 2]) {\n\t\t\t\t\t\tindex++;\n\t\t\t\t\t}\n\n\t\t\t\t\tbreak;\n\t\t\t\tcase S.HEADER_FIELD_START:\n\t\t\t\t\tstate = S.HEADER_FIELD;\n\t\t\t\t\tmark('onHeaderField');\n\t\t\t\t\tindex = 0;\n\t\t\t\t\t// falls through\n\t\t\t\tcase S.HEADER_FIELD:\n\t\t\t\t\tif (c === CR) {\n\t\t\t\t\t\tclear('onHeaderField');\n\t\t\t\t\t\tstate = S.HEADERS_ALMOST_DONE;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\n\t\t\t\t\tindex++;\n\t\t\t\t\tif (c === HYPHEN) {\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\n\t\t\t\t\tif (c === COLON) {\n\t\t\t\t\t\tif (index === 1) {\n\t\t\t\t\t\t\t// empty header field\n\t\t\t\t\t\t\treturn;\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tdataCallback('onHeaderField', true);\n\t\t\t\t\t\tstate = S.HEADER_VALUE_START;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\n\t\t\t\t\tcl = lower(c);\n\t\t\t\t\tif (cl < A || cl > Z) {\n\t\t\t\t\t\treturn;\n\t\t\t\t\t}\n\n\t\t\t\t\tbreak;\n\t\t\t\tcase S.HEADER_VALUE_START:\n\t\t\t\t\tif (c === SPACE) {\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\n\t\t\t\t\tmark('onHeaderValue');\n\t\t\t\t\tstate = S.HEADER_VALUE;\n\t\t\t\t\t// falls through\n\t\t\t\tcase S.HEADER_VALUE:\n\t\t\t\t\tif (c === CR) {\n\t\t\t\t\t\tdataCallback('onHeaderValue', true);\n\t\t\t\t\t\tcallback('onHeaderEnd');\n\t\t\t\t\t\tstate = S.HEADER_VALUE_ALMOST_DONE;\n\t\t\t\t\t}\n\n\t\t\t\t\tbreak;\n\t\t\t\tcase S.HEADER_VALUE_ALMOST_DONE:\n\t\t\t\t\tif (c !== LF) {\n\t\t\t\t\t\treturn;\n\t\t\t\t\t}\n\n\t\t\t\t\tstate = S.HEADER_FIELD_START;\n\t\t\t\t\tbreak;\n\t\t\t\tcase S.HEADERS_ALMOST_DONE:\n\t\t\t\t\tif (c !== LF) {\n\t\t\t\t\t\treturn;\n\t\t\t\t\t}\n\n\t\t\t\t\tcallback('onHeadersEnd');\n\t\t\t\t\tstate = S.PART_DATA_START;\n\t\t\t\t\tbreak;\n\t\t\t\tcase S.PART_DATA_START:\n\t\t\t\t\tstate = S.PART_DATA;\n\t\t\t\t\tmark('onPartData');\n\t\t\t\t\t// falls through\n\t\t\t\tcase S.PART_DATA:\n\t\t\t\t\tpreviousIndex = index;\n\n\t\t\t\t\tif (index === 0) {\n\t\t\t\t\t\t// boyer-moore derrived algorithm to safely skip non-boundary data\n\t\t\t\t\t\ti += boundaryEnd;\n\t\t\t\t\t\twhile (i < bufferLength && !(data[i] in boundaryChars)) {\n\t\t\t\t\t\t\ti += boundaryLength;\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\ti -= boundaryEnd;\n\t\t\t\t\t\tc = data[i];\n\t\t\t\t\t}\n\n\t\t\t\t\tif (index < boundary.length) {\n\t\t\t\t\t\tif (boundary[index] === c) {\n\t\t\t\t\t\t\tif (index === 0) {\n\t\t\t\t\t\t\t\tdataCallback('onPartData', true);\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\tindex++;\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tindex = 0;\n\t\t\t\t\t\t}\n\t\t\t\t\t} else if (index === boundary.length) {\n\t\t\t\t\t\tindex++;\n\t\t\t\t\t\tif (c === CR) {\n\t\t\t\t\t\t\t// CR = part boundary\n\t\t\t\t\t\t\tflags |= F.PART_BOUNDARY;\n\t\t\t\t\t\t} else if (c === HYPHEN) {\n\t\t\t\t\t\t\t// HYPHEN = end boundary\n\t\t\t\t\t\t\tflags |= F.LAST_BOUNDARY;\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tindex = 0;\n\t\t\t\t\t\t}\n\t\t\t\t\t} else if (index - 1 === boundary.length) {\n\t\t\t\t\t\tif (flags & F.PART_BOUNDARY) {\n\t\t\t\t\t\t\tindex = 0;\n\t\t\t\t\t\t\tif (c === LF) {\n\t\t\t\t\t\t\t\t// unset the PART_BOUNDARY flag\n\t\t\t\t\t\t\t\tflags &= ~F.PART_BOUNDARY;\n\t\t\t\t\t\t\t\tcallback('onPartEnd');\n\t\t\t\t\t\t\t\tcallback('onPartBegin');\n\t\t\t\t\t\t\t\tstate = S.HEADER_FIELD_START;\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t} else if (flags & F.LAST_BOUNDARY) {\n\t\t\t\t\t\t\tif (c === HYPHEN) {\n\t\t\t\t\t\t\t\tcallback('onPartEnd');\n\t\t\t\t\t\t\t\tstate = S.END;\n\t\t\t\t\t\t\t\tflags = 0;\n\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\tindex = 0;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tindex = 0;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\tif (index > 0) {\n\t\t\t\t\t\t// when matching a possible boundary, keep a lookbehind reference\n\t\t\t\t\t\t// in case it turns out to be a false lead\n\t\t\t\t\t\tlookbehind[index - 1] = c;\n\t\t\t\t\t} else if (previousIndex > 0) {\n\t\t\t\t\t\t// if our boundary turned out to be rubbish, the captured lookbehind\n\t\t\t\t\t\t// belongs to partData\n\t\t\t\t\t\tconst _lookbehind = new Uint8Array(lookbehind.buffer, lookbehind.byteOffset, lookbehind.byteLength);\n\t\t\t\t\t\tcallback('onPartData', 0, previousIndex, _lookbehind);\n\t\t\t\t\t\tpreviousIndex = 0;\n\t\t\t\t\t\tmark('onPartData');\n\n\t\t\t\t\t\t// reconsider the current character even so it interrupted the sequence\n\t\t\t\t\t\t// it could be the beginning of a new sequence\n\t\t\t\t\t\ti--;\n\t\t\t\t\t}\n\n\t\t\t\t\tbreak;\n\t\t\t\tcase S.END:\n\t\t\t\t\tbreak;\n\t\t\t\tdefault:\n\t\t\t\t\tthrow new Error(`Unexpected state entered: ${state}`);\n\t\t\t}\n\t\t}\n\n\t\tdataCallback('onHeaderField');\n\t\tdataCallback('onHeaderValue');\n\t\tdataCallback('onPartData');\n\n\t\t// Update properties for the next call\n\t\tthis.index = index;\n\t\tthis.state = state;\n\t\tthis.flags = flags;\n\t}\n\n\tend() {\n\t\tif ((this.state === S.HEADER_FIELD_START && this.index === 0) ||\n\t\t\t(this.state === S.PART_DATA && this.index === this.boundary.length)) {\n\t\t\tthis.onPartEnd();\n\t\t} else if (this.state !== S.END) {\n\t\t\tthrow new Error('MultipartParser.end(): stream ended unexpectedly');\n\t\t}\n\t}\n}\n\nfunction _fileName(headerValue) {\n\t// matches either a quoted-string or a token (RFC 2616 section 19.5.1)\n\tconst m = headerValue.match(/\\bfilename=(\"(.*?)\"|([^()<>@,;:\\\\\"/[\\]?={}\\s\\t]+))($|;\\s)/i);\n\tif (!m) {\n\t\treturn;\n\t}\n\n\tconst match = m[2] || m[3] || '';\n\tlet filename = match.slice(match.lastIndexOf('\\\\') + 1);\n\tfilename = filename.replace(/%22/g, '\"');\n\tfilename = filename.replace(/&#(\\d{4});/g, (m, code) => {\n\t\treturn String.fromCharCode(code);\n\t});\n\treturn filename;\n}\n\nexport async function toFormData(Body, ct) {\n\tif (!/multipart/i.test(ct)) {\n\t\tthrow new TypeError('Failed to fetch');\n\t}\n\n\tconst m = ct.match(/boundary=(?:\"([^\"]+)\"|([^;]+))/i);\n\n\tif (!m) {\n\t\tthrow new TypeError('no or bad content-type header, no multipart boundary');\n\t}\n\n\tconst parser = new MultipartParser(m[1] || m[2]);\n\n\tlet headerField;\n\tlet headerValue;\n\tlet entryValue;\n\tlet entryName;\n\tlet contentType;\n\tlet filename;\n\tconst entryChunks = [];\n\tconst formData = new FormData();\n\n\tconst onPartData = ui8a => {\n\t\tentryValue += decoder.decode(ui8a, {stream: true});\n\t};\n\n\tconst appendToFile = ui8a => {\n\t\tentryChunks.push(ui8a);\n\t};\n\n\tconst appendFileToFormData = () => {\n\t\tconst file = new File(entryChunks, filename, {type: contentType});\n\t\tformData.append(entryName, file);\n\t};\n\n\tconst appendEntryToFormData = () => {\n\t\tformData.append(entryName, entryValue);\n\t};\n\n\tconst decoder = new TextDecoder('utf-8');\n\tdecoder.decode();\n\n\tparser.onPartBegin = function () {\n\t\tparser.onPartData = onPartData;\n\t\tparser.onPartEnd = appendEntryToFormData;\n\n\t\theaderField = '';\n\t\theaderValue = '';\n\t\tentryValue = '';\n\t\tentryName = '';\n\t\tcontentType = '';\n\t\tfilename = null;\n\t\tentryChunks.length = 0;\n\t};\n\n\tparser.onHeaderField = function (ui8a) {\n\t\theaderField += decoder.decode(ui8a, {stream: true});\n\t};\n\n\tparser.onHeaderValue = function (ui8a) {\n\t\theaderValue += decoder.decode(ui8a, {stream: true});\n\t};\n\n\tparser.onHeaderEnd = function () {\n\t\theaderValue += decoder.decode();\n\t\theaderField = headerField.toLowerCase();\n\n\t\tif (headerField === 'content-disposition') {\n\t\t\t// matches either a quoted-string or a token (RFC 2616 section 19.5.1)\n\t\t\tconst m = headerValue.match(/\\bname=(\"([^\"]*)\"|([^()<>@,;:\\\\\"/[\\]?={}\\s\\t]+))/i);\n\n\t\t\tif (m) {\n\t\t\t\tentryName = m[2] || m[3] || '';\n\t\t\t}\n\n\t\t\tfilename = _fileName(headerValue);\n\n\t\t\tif (filename) {\n\t\t\t\tparser.onPartData = appendToFile;\n\t\t\t\tparser.onPartEnd = appendFileToFormData;\n\t\t\t}\n\t\t} else if (headerField === 'content-type') {\n\t\t\tcontentType = headerValue;\n\t\t}\n\n\t\theaderValue = '';\n\t\theaderField = '';\n\t};\n\n\tfor await (const chunk of Body) {\n\t\tparser.write(chunk);\n\t}\n\n\tparser.end();\n\n\treturn formData;\n}\n"],"mappings":";;;;;AAAA,SAAQA,IAAI,QAAO,oBAAoB;AACvC,SAAQC,QAAQ,QAAO,8BAA8B;AAErD,IAAIC,CAAC,GAAG,CAAC;AACT,IAAMC,CAAC,GAAG;EACTC,cAAc,EAAEF,CAAC,EAAE;EACnBG,kBAAkB,EAAEH,CAAC,EAAE;EACvBI,YAAY,EAAEJ,CAAC,EAAE;EACjBK,kBAAkB,EAAEL,CAAC,EAAE;EACvBM,YAAY,EAAEN,CAAC,EAAE;EACjBO,wBAAwB,EAAEP,CAAC,EAAE;EAC7BQ,mBAAmB,EAAER,CAAC,EAAE;EACxBS,eAAe,EAAET,CAAC,EAAE;EACpBU,SAAS,EAAEV,CAAC,EAAE;EACdW,GAAG,EAAEX,CAAC;AACP,CAAC;AAED,IAAIY,CAAC,GAAG,CAAC;AACT,IAAMC,CAAC,GAAG;EACTC,aAAa,EAAEF,CAAC;EAChBG,aAAa,EAAEH,CAAC,IAAI;AACrB,CAAC;AAED,IAAMI,EAAE,GAAG,EAAE;AACb,IAAMC,EAAE,GAAG,EAAE;AACb,IAAMC,KAAK,GAAG,EAAE;AAChB,IAAMC,MAAM,GAAG,EAAE;AACjB,IAAMC,KAAK,GAAG,EAAE;AAChB,IAAMC,CAAC,GAAG,EAAE;AACZ,IAAMC,CAAC,GAAG,GAAG;AAEb,IAAMC,KAAK,GAAG,SAARA,KAAK,CAAGC,CAAC;EAAA,OAAIA,CAAC,GAAG,IAAI;AAAA;AAE3B,IAAMC,IAAI,GAAG,SAAPA,IAAI,GAAS,CAAC,CAAC;AAAC,IAEhBC,eAAe;EACpB;AACD;AACA;EACC,yBAAYC,QAAQ,EAAE;IAAA;IACrB,IAAI,CAACC,KAAK,GAAG,CAAC;IACd,IAAI,CAACC,KAAK,GAAG,CAAC;IAEd,IAAI,CAACC,WAAW,GAAGL,IAAI;IACvB,IAAI,CAACM,aAAa,GAAGN,IAAI;IACzB,IAAI,CAACO,YAAY,GAAGP,IAAI;IACxB,IAAI,CAACQ,aAAa,GAAGR,IAAI;IACzB,IAAI,CAACS,WAAW,GAAGT,IAAI;IACvB,IAAI,CAACU,UAAU,GAAGV,IAAI;IACtB,IAAI,CAACW,SAAS,GAAGX,IAAI;IAErB,IAAI,CAACY,aAAa,GAAG,CAAC,CAAC;IAEvBV,QAAQ,GAAG,QAAQ,GAAGA,QAAQ;IAC9B,IAAMW,IAAI,GAAG,IAAIC,UAAU,CAACZ,QAAQ,CAACa,MAAM,CAAC;IAC5C,KAAK,IAAIC,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAGd,QAAQ,CAACa,MAAM,EAAEC,CAAC,EAAE,EAAE;MACzCH,IAAI,CAACG,CAAC,CAAC,GAAGd,QAAQ,CAACe,UAAU,CAACD,CAAC,CAAC;MAChC,IAAI,CAACJ,aAAa,CAACC,IAAI,CAACG,CAAC,CAAC,CAAC,GAAG,IAAI;IACnC;IAEA,IAAI,CAACd,QAAQ,GAAGW,IAAI;IACpB,IAAI,CAACK,UAAU,GAAG,IAAIJ,UAAU,CAAC,IAAI,CAACZ,QAAQ,CAACa,MAAM,GAAG,CAAC,CAAC;IAC1D,IAAI,CAACI,KAAK,GAAG3C,CAAC,CAACC,cAAc;EAC9B;;EAEA;AACD;AACA;EAFC;IAAA;IAAA,OAGA,eAAM2C,IAAI,EAAE;MAAA;MACX,IAAIJ,CAAC,GAAG,CAAC;MACT,IAAMK,OAAO,GAAGD,IAAI,CAACL,MAAM;MAC3B,IAAIO,aAAa,GAAG,IAAI,CAACnB,KAAK;MAC9B,IAAKe,UAAU,GAAkD,IAAI,CAAhEA,UAAU;QAAEhB,QAAQ,GAAwC,IAAI,CAApDA,QAAQ;QAAEU,aAAa,GAAyB,IAAI,CAA1CA,aAAa;QAAET,KAAK,GAAkB,IAAI,CAA3BA,KAAK;QAAEgB,KAAK,GAAW,IAAI,CAApBA,KAAK;QAAEf,KAAK,GAAI,IAAI,CAAbA,KAAK;MAC7D,IAAMmB,cAAc,GAAG,IAAI,CAACrB,QAAQ,CAACa,MAAM;MAC3C,IAAMS,WAAW,GAAGD,cAAc,GAAG,CAAC;MACtC,IAAME,YAAY,GAAGL,IAAI,CAACL,MAAM;MAChC,IAAIhB,CAAC;MACL,IAAI2B,EAAE;MAEN,IAAMC,IAAI,GAAG,SAAPA,IAAI,CAAGC,IAAI,EAAI;QACpB,KAAI,CAACA,IAAI,GAAG,MAAM,CAAC,GAAGZ,CAAC;MACxB,CAAC;MAED,IAAMa,KAAK,GAAG,SAARA,KAAK,CAAGD,IAAI,EAAI;QACrB,OAAO,KAAI,CAACA,IAAI,GAAG,MAAM,CAAC;MAC3B,CAAC;MAED,IAAME,QAAQ,GAAG,SAAXA,QAAQ,CAAIC,cAAc,EAAEC,KAAK,EAAEC,GAAG,EAAEpB,IAAI,EAAK;QACtD,IAAImB,KAAK,KAAKE,SAAS,IAAIF,KAAK,KAAKC,GAAG,EAAE;UACzC,KAAI,CAACF,cAAc,CAAC,CAAClB,IAAI,IAAIA,IAAI,CAACsB,QAAQ,CAACH,KAAK,EAAEC,GAAG,CAAC,CAAC;QACxD;MACD,CAAC;MAED,IAAMG,YAAY,GAAG,SAAfA,YAAY,CAAIR,IAAI,EAAEC,KAAK,EAAK;QACrC,IAAMQ,UAAU,GAAGT,IAAI,GAAG,MAAM;QAChC,IAAI,EAAES,UAAU,IAAI,KAAI,CAAC,EAAE;UAC1B;QACD;QAEA,IAAIR,KAAK,EAAE;UACVC,QAAQ,CAACF,IAAI,EAAE,KAAI,CAACS,UAAU,CAAC,EAAErB,CAAC,EAAEI,IAAI,CAAC;UACzC,OAAO,KAAI,CAACiB,UAAU,CAAC;QACxB,CAAC,MAAM;UACNP,QAAQ,CAACF,IAAI,EAAE,KAAI,CAACS,UAAU,CAAC,EAAEjB,IAAI,CAACL,MAAM,EAAEK,IAAI,CAAC;UACnD,KAAI,CAACiB,UAAU,CAAC,GAAG,CAAC;QACrB;MACD,CAAC;MAED,KAAKrB,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAGK,OAAO,EAAEL,CAAC,EAAE,EAAE;QAC7BjB,CAAC,GAAGqB,IAAI,CAACJ,CAAC,CAAC;QAEX,QAAQG,KAAK;UACZ,KAAK3C,CAAC,CAACC,cAAc;YACpB,IAAI0B,KAAK,KAAKD,QAAQ,CAACa,MAAM,GAAG,CAAC,EAAE;cAClC,IAAIhB,CAAC,KAAKL,MAAM,EAAE;gBACjBU,KAAK,IAAIhB,CAAC,CAACE,aAAa;cACzB,CAAC,MAAM,IAAIS,CAAC,KAAKP,EAAE,EAAE;gBACpB;cACD;cAEAW,KAAK,EAAE;cACP;YACD,CAAC,MAAM,IAAIA,KAAK,GAAG,CAAC,KAAKD,QAAQ,CAACa,MAAM,GAAG,CAAC,EAAE;cAC7C,IAAIX,KAAK,GAAGhB,CAAC,CAACE,aAAa,IAAIS,CAAC,KAAKL,MAAM,EAAE;gBAC5CyB,KAAK,GAAG3C,CAAC,CAACU,GAAG;gBACbkB,KAAK,GAAG,CAAC;cACV,CAAC,MAAM,IAAI,EAAEA,KAAK,GAAGhB,CAAC,CAACE,aAAa,CAAC,IAAIS,CAAC,KAAKR,EAAE,EAAE;gBAClDY,KAAK,GAAG,CAAC;gBACT2B,QAAQ,CAAC,aAAa,CAAC;gBACvBX,KAAK,GAAG3C,CAAC,CAACE,kBAAkB;cAC7B,CAAC,MAAM;gBACN;cACD;cAEA;YACD;YAEA,IAAIqB,CAAC,KAAKG,QAAQ,CAACC,KAAK,GAAG,CAAC,CAAC,EAAE;cAC9BA,KAAK,GAAG,CAAC,CAAC;YACX;YAEA,IAAIJ,CAAC,KAAKG,QAAQ,CAACC,KAAK,GAAG,CAAC,CAAC,EAAE;cAC9BA,KAAK,EAAE;YACR;YAEA;UACD,KAAK3B,CAAC,CAACE,kBAAkB;YACxByC,KAAK,GAAG3C,CAAC,CAACG,YAAY;YACtBgD,IAAI,CAAC,eAAe,CAAC;YACrBxB,KAAK,GAAG,CAAC;UACT;UACD,KAAK3B,CAAC,CAACG,YAAY;YAClB,IAAIoB,CAAC,KAAKP,EAAE,EAAE;cACbqC,KAAK,CAAC,eAAe,CAAC;cACtBV,KAAK,GAAG3C,CAAC,CAACO,mBAAmB;cAC7B;YACD;YAEAoB,KAAK,EAAE;YACP,IAAIJ,CAAC,KAAKL,MAAM,EAAE;cACjB;YACD;YAEA,IAAIK,CAAC,KAAKJ,KAAK,EAAE;cAChB,IAAIQ,KAAK,KAAK,CAAC,EAAE;gBAChB;gBACA;cACD;cAEAiC,YAAY,CAAC,eAAe,EAAE,IAAI,CAAC;cACnCjB,KAAK,GAAG3C,CAAC,CAACI,kBAAkB;cAC5B;YACD;YAEA8C,EAAE,GAAG5B,KAAK,CAACC,CAAC,CAAC;YACb,IAAI2B,EAAE,GAAG9B,CAAC,IAAI8B,EAAE,GAAG7B,CAAC,EAAE;cACrB;YACD;YAEA;UACD,KAAKrB,CAAC,CAACI,kBAAkB;YACxB,IAAImB,CAAC,KAAKN,KAAK,EAAE;cAChB;YACD;YAEAkC,IAAI,CAAC,eAAe,CAAC;YACrBR,KAAK,GAAG3C,CAAC,CAACK,YAAY;UACtB;UACD,KAAKL,CAAC,CAACK,YAAY;YAClB,IAAIkB,CAAC,KAAKP,EAAE,EAAE;cACb4C,YAAY,CAAC,eAAe,EAAE,IAAI,CAAC;cACnCN,QAAQ,CAAC,aAAa,CAAC;cACvBX,KAAK,GAAG3C,CAAC,CAACM,wBAAwB;YACnC;YAEA;UACD,KAAKN,CAAC,CAACM,wBAAwB;YAC9B,IAAIiB,CAAC,KAAKR,EAAE,EAAE;cACb;YACD;YAEA4B,KAAK,GAAG3C,CAAC,CAACE,kBAAkB;YAC5B;UACD,KAAKF,CAAC,CAACO,mBAAmB;YACzB,IAAIgB,CAAC,KAAKR,EAAE,EAAE;cACb;YACD;YAEAuC,QAAQ,CAAC,cAAc,CAAC;YACxBX,KAAK,GAAG3C,CAAC,CAACQ,eAAe;YACzB;UACD,KAAKR,CAAC,CAACQ,eAAe;YACrBmC,KAAK,GAAG3C,CAAC,CAACS,SAAS;YACnB0C,IAAI,CAAC,YAAY,CAAC;UAClB;UACD,KAAKnD,CAAC,CAACS,SAAS;YACfqC,aAAa,GAAGnB,KAAK;YAErB,IAAIA,KAAK,KAAK,CAAC,EAAE;cAChB;cACAa,CAAC,IAAIQ,WAAW;cAChB,OAAOR,CAAC,GAAGS,YAAY,IAAI,EAAEL,IAAI,CAACJ,CAAC,CAAC,IAAIJ,aAAa,CAAC,EAAE;gBACvDI,CAAC,IAAIO,cAAc;cACpB;cAEAP,CAAC,IAAIQ,WAAW;cAChBzB,CAAC,GAAGqB,IAAI,CAACJ,CAAC,CAAC;YACZ;YAEA,IAAIb,KAAK,GAAGD,QAAQ,CAACa,MAAM,EAAE;cAC5B,IAAIb,QAAQ,CAACC,KAAK,CAAC,KAAKJ,CAAC,EAAE;gBAC1B,IAAII,KAAK,KAAK,CAAC,EAAE;kBAChBiC,YAAY,CAAC,YAAY,EAAE,IAAI,CAAC;gBACjC;gBAEAjC,KAAK,EAAE;cACR,CAAC,MAAM;gBACNA,KAAK,GAAG,CAAC;cACV;YACD,CAAC,MAAM,IAAIA,KAAK,KAAKD,QAAQ,CAACa,MAAM,EAAE;cACrCZ,KAAK,EAAE;cACP,IAAIJ,CAAC,KAAKP,EAAE,EAAE;gBACb;gBACAY,KAAK,IAAIhB,CAAC,CAACC,aAAa;cACzB,CAAC,MAAM,IAAIU,CAAC,KAAKL,MAAM,EAAE;gBACxB;gBACAU,KAAK,IAAIhB,CAAC,CAACE,aAAa;cACzB,CAAC,MAAM;gBACNa,KAAK,GAAG,CAAC;cACV;YACD,CAAC,MAAM,IAAIA,KAAK,GAAG,CAAC,KAAKD,QAAQ,CAACa,MAAM,EAAE;cACzC,IAAIX,KAAK,GAAGhB,CAAC,CAACC,aAAa,EAAE;gBAC5Bc,KAAK,GAAG,CAAC;gBACT,IAAIJ,CAAC,KAAKR,EAAE,EAAE;kBACb;kBACAa,KAAK,IAAI,CAAChB,CAAC,CAACC,aAAa;kBACzByC,QAAQ,CAAC,WAAW,CAAC;kBACrBA,QAAQ,CAAC,aAAa,CAAC;kBACvBX,KAAK,GAAG3C,CAAC,CAACE,kBAAkB;kBAC5B;gBACD;cACD,CAAC,MAAM,IAAI0B,KAAK,GAAGhB,CAAC,CAACE,aAAa,EAAE;gBACnC,IAAIS,CAAC,KAAKL,MAAM,EAAE;kBACjBoC,QAAQ,CAAC,WAAW,CAAC;kBACrBX,KAAK,GAAG3C,CAAC,CAACU,GAAG;kBACbkB,KAAK,GAAG,CAAC;gBACV,CAAC,MAAM;kBACND,KAAK,GAAG,CAAC;gBACV;cACD,CAAC,MAAM;gBACNA,KAAK,GAAG,CAAC;cACV;YACD;YAEA,IAAIA,KAAK,GAAG,CAAC,EAAE;cACd;cACA;cACAe,UAAU,CAACf,KAAK,GAAG,CAAC,CAAC,GAAGJ,CAAC;YAC1B,CAAC,MAAM,IAAIuB,aAAa,GAAG,CAAC,EAAE;cAC7B;cACA;cACA,IAAMgB,WAAW,GAAG,IAAIxB,UAAU,CAACI,UAAU,CAACqB,MAAM,EAAErB,UAAU,CAACsB,UAAU,EAAEtB,UAAU,CAACuB,UAAU,CAAC;cACnGX,QAAQ,CAAC,YAAY,EAAE,CAAC,EAAER,aAAa,EAAEgB,WAAW,CAAC;cACrDhB,aAAa,GAAG,CAAC;cACjBK,IAAI,CAAC,YAAY,CAAC;;cAElB;cACA;cACAX,CAAC,EAAE;YACJ;YAEA;UACD,KAAKxC,CAAC,CAACU,GAAG;YACT;UACD;YACC,MAAM,IAAIwD,KAAK,qCAA8BvB,KAAK,EAAG;QAAC;MAEzD;MAEAiB,YAAY,CAAC,eAAe,CAAC;MAC7BA,YAAY,CAAC,eAAe,CAAC;MAC7BA,YAAY,CAAC,YAAY,CAAC;;MAE1B;MACA,IAAI,CAACjC,KAAK,GAAGA,KAAK;MAClB,IAAI,CAACgB,KAAK,GAAGA,KAAK;MAClB,IAAI,CAACf,KAAK,GAAGA,KAAK;IACnB;EAAC;IAAA;IAAA,OAED,eAAM;MACL,IAAK,IAAI,CAACe,KAAK,KAAK3C,CAAC,CAACE,kBAAkB,IAAI,IAAI,CAACyB,KAAK,KAAK,CAAC,IAC1D,IAAI,CAACgB,KAAK,KAAK3C,CAAC,CAACS,SAAS,IAAI,IAAI,CAACkB,KAAK,KAAK,IAAI,CAACD,QAAQ,CAACa,MAAO,EAAE;QACrE,IAAI,CAACJ,SAAS,EAAE;MACjB,CAAC,MAAM,IAAI,IAAI,CAACQ,KAAK,KAAK3C,CAAC,CAACU,GAAG,EAAE;QAChC,MAAM,IAAIwD,KAAK,CAAC,kDAAkD,CAAC;MACpE;IACD;EAAC;EAAA;AAAA;AAGF,SAASC,SAAS,CAACC,WAAW,EAAE;EAC/B;EACA,IAAMC,CAAC,GAAGD,WAAW,CAACE,KAAK,CAAC,4DAA4D,CAAC;EACzF,IAAI,CAACD,CAAC,EAAE;IACP;EACD;EAEA,IAAMC,KAAK,GAAGD,CAAC,CAAC,CAAC,CAAC,IAAIA,CAAC,CAAC,CAAC,CAAC,IAAI,EAAE;EAChC,IAAIE,QAAQ,GAAGD,KAAK,CAACE,KAAK,CAACF,KAAK,CAACG,WAAW,CAAC,IAAI,CAAC,GAAG,CAAC,CAAC;EACvDF,QAAQ,GAAGA,QAAQ,CAACG,OAAO,CAAC,MAAM,EAAE,GAAG,CAAC;EACxCH,QAAQ,GAAGA,QAAQ,CAACG,OAAO,CAAC,aAAa,EAAE,UAACL,CAAC,EAAEM,IAAI,EAAK;IACvD,OAAOC,MAAM,CAACC,YAAY,CAACF,IAAI,CAAC;EACjC,CAAC,CAAC;EACF,OAAOJ,QAAQ;AAChB;AAEA,gBAAsBO,UAAU;EAAA;AAAA;AAgG/B;EAAA,yEAhGM,iBAA0BC,IAAI,EAAEC,EAAE;IAAA;IAAA;MAAA;QAAA;UAAA;YAAA,IACnC,YAAY,CAACC,IAAI,CAACD,EAAE,CAAC;cAAA;cAAA;YAAA;YAAA,MACnB,IAAIE,SAAS,CAAC,iBAAiB,CAAC;UAAA;YAGjCb,CAAC,GAAGW,EAAE,CAACV,KAAK,CAAC,iCAAiC,CAAC;YAAA,IAEhDD,CAAC;cAAA;cAAA;YAAA;YAAA,MACC,IAAIa,SAAS,CAAC,sDAAsD,CAAC;UAAA;YAGtEC,MAAM,GAAG,IAAI1D,eAAe,CAAC4C,CAAC,CAAC,CAAC,CAAC,IAAIA,CAAC,CAAC,CAAC,CAAC,CAAC;YAQ1Ce,WAAW,GAAG,EAAE;YAChBC,QAAQ,GAAG,IAAIvF,QAAQ,EAAE;YAEzBoC,UAAU,GAAG,SAAbA,UAAU,CAAGG,IAAI,EAAI;cAC1BiD,UAAU,IAAIC,OAAO,CAACC,MAAM,CAACnD,IAAI,EAAE;gBAACoD,MAAM,EAAE;cAAI,CAAC,CAAC;YACnD,CAAC;YAEKC,YAAY,GAAG,SAAfA,YAAY,CAAGrD,IAAI,EAAI;cAC5B+C,WAAW,CAACO,IAAI,CAACtD,IAAI,CAAC;YACvB,CAAC;YAEKuD,oBAAoB,GAAG,SAAvBA,oBAAoB,GAAS;cAClC,IAAMC,IAAI,GAAG,IAAIhG,IAAI,CAACuF,WAAW,EAAEb,QAAQ,EAAE;gBAACuB,IAAI,EAAEC;cAAW,CAAC,CAAC;cACjEV,QAAQ,CAACW,MAAM,CAACC,SAAS,EAAEJ,IAAI,CAAC;YACjC,CAAC;YAEKK,qBAAqB,GAAG,SAAxBA,qBAAqB,GAAS;cACnCb,QAAQ,CAACW,MAAM,CAACC,SAAS,EAAEX,UAAU,CAAC;YACvC,CAAC;YAEKC,OAAO,GAAG,IAAIY,WAAW,CAAC,OAAO,CAAC;YACxCZ,OAAO,CAACC,MAAM,EAAE;YAEhBL,MAAM,CAAClD,WAAW,GAAG,YAAY;cAChCkD,MAAM,CAACjD,UAAU,GAAGA,UAAU;cAC9BiD,MAAM,CAAChD,SAAS,GAAG+D,qBAAqB;cAExCE,WAAW,GAAG,EAAE;cAChBhC,WAAW,GAAG,EAAE;cAChBkB,UAAU,GAAG,EAAE;cACfW,SAAS,GAAG,EAAE;cACdF,WAAW,GAAG,EAAE;cAChBxB,QAAQ,GAAG,IAAI;cACfa,WAAW,CAAC7C,MAAM,GAAG,CAAC;YACvB,CAAC;YAED4C,MAAM,CAACrD,aAAa,GAAG,UAAUO,IAAI,EAAE;cACtC+D,WAAW,IAAIb,OAAO,CAACC,MAAM,CAACnD,IAAI,EAAE;gBAACoD,MAAM,EAAE;cAAI,CAAC,CAAC;YACpD,CAAC;YAEDN,MAAM,CAACnD,aAAa,GAAG,UAAUK,IAAI,EAAE;cACtC+B,WAAW,IAAImB,OAAO,CAACC,MAAM,CAACnD,IAAI,EAAE;gBAACoD,MAAM,EAAE;cAAI,CAAC,CAAC;YACpD,CAAC;YAEDN,MAAM,CAACtD,WAAW,GAAG,YAAY;cAChCuC,WAAW,IAAImB,OAAO,CAACC,MAAM,EAAE;cAC/BY,WAAW,GAAGA,WAAW,CAACC,WAAW,EAAE;cAEvC,IAAID,WAAW,KAAK,qBAAqB,EAAE;gBAC1C;gBACA,IAAM/B,EAAC,GAAGD,WAAW,CAACE,KAAK,CAAC,mDAAmD,CAAC;gBAEhF,IAAID,EAAC,EAAE;kBACN4B,SAAS,GAAG5B,EAAC,CAAC,CAAC,CAAC,IAAIA,EAAC,CAAC,CAAC,CAAC,IAAI,EAAE;gBAC/B;gBAEAE,QAAQ,GAAGJ,SAAS,CAACC,WAAW,CAAC;gBAEjC,IAAIG,QAAQ,EAAE;kBACbY,MAAM,CAACjD,UAAU,GAAGwD,YAAY;kBAChCP,MAAM,CAAChD,SAAS,GAAGyD,oBAAoB;gBACxC;cACD,CAAC,MAAM,IAAIQ,WAAW,KAAK,cAAc,EAAE;gBAC1CL,WAAW,GAAG3B,WAAW;cAC1B;cAEAA,WAAW,GAAG,EAAE;cAChBgC,WAAW,GAAG,EAAE;YACjB,CAAC;YAAC;YAAA;YAAA;YAAA,2BAEwBrB,IAAI;UAAA;YAAA;YAAA;UAAA;YAAA;cAAA;cAAA;YAAA;YAAbuB,KAAK;YACrBnB,MAAM,CAACoB,KAAK,CAACD,KAAK,CAAC;UAAC;YAAA;YAAA;YAAA;UAAA;YAAA;YAAA;UAAA;YAAA;YAAA;YAAA;YAAA;UAAA;YAAA;YAAA;YAAA;cAAA;cAAA;YAAA;YAAA;YAAA;UAAA;YAAA;YAAA;cAAA;cAAA;YAAA;YAAA;UAAA;YAAA;UAAA;YAAA;UAAA;YAGrBnB,MAAM,CAAC1B,GAAG,EAAE;YAAC,iCAEN4B,QAAQ;UAAA;UAAA;YAAA;QAAA;MAAA;IAAA;EAAA,CACf;EAAA;AAAA"},"metadata":{},"sourceType":"module","externalDependencies":[]}