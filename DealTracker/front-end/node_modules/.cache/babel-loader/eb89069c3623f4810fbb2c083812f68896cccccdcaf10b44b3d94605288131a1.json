{"ast":null,"code":"import _asyncToGenerator from \"/home/ubuntu/environment/public_html/DealTracker/front-end/node_modules/@babel/runtime/helpers/esm/asyncToGenerator.js\";\nimport _classCallCheck from \"/home/ubuntu/environment/public_html/DealTracker/front-end/node_modules/@babel/runtime/helpers/esm/classCallCheck.js\";\nimport _createClass from \"/home/ubuntu/environment/public_html/DealTracker/front-end/node_modules/@babel/runtime/helpers/esm/createClass.js\";\nimport _classPrivateFieldInitSpec from \"/home/ubuntu/environment/public_html/DealTracker/front-end/node_modules/@babel/runtime/helpers/esm/classPrivateFieldInitSpec.js\";\nimport _classPrivateFieldSet from \"/home/ubuntu/environment/public_html/DealTracker/front-end/node_modules/@babel/runtime/helpers/esm/classPrivateFieldSet.js\";\nimport _classPrivateFieldGet from \"/home/ubuntu/environment/public_html/DealTracker/front-end/node_modules/@babel/runtime/helpers/esm/classPrivateFieldGet.js\";\nimport _regeneratorRuntime from \"/home/ubuntu/environment/public_html/DealTracker/front-end/node_modules/@babel/runtime/helpers/esm/regeneratorRuntime.js\";\nimport _createForOfIteratorHelper from \"/home/ubuntu/environment/public_html/DealTracker/front-end/node_modules/@babel/runtime/helpers/esm/createForOfIteratorHelper.js\";\nimport _wrapAsyncGenerator from \"/home/ubuntu/environment/public_html/DealTracker/front-end/node_modules/@babel/runtime/helpers/esm/wrapAsyncGenerator.js\";\nimport _awaitAsyncGenerator from \"/home/ubuntu/environment/public_html/DealTracker/front-end/node_modules/@babel/runtime/helpers/esm/awaitAsyncGenerator.js\";\nimport _asyncGeneratorDelegate from \"/home/ubuntu/environment/public_html/DealTracker/front-end/node_modules/@babel/runtime/helpers/esm/asyncGeneratorDelegate.js\";\nimport _asyncIterator from \"/home/ubuntu/environment/public_html/DealTracker/front-end/node_modules/@babel/runtime/helpers/esm/asyncIterator.js\";\nvar _parts, _type, _size, _endings;\nvar _Symbol$toStringTag, _Symbol$hasInstance;\n/*! fetch-blob. MIT License. Jimmy Wärting <https://jimmy.warting.se/opensource> */\n\n// TODO (jimmywarting): in the feature use conditional loading with top level await (requires 14.x)\n// Node has recently added whatwg stream into core\n\nimport './streams.cjs';\n\n// 64 KiB (same size chrome slice theirs blob into Uint8array's)\nvar POOL_SIZE = 65536;\n\n/** @param {(Blob | Uint8Array)[]} parts */\nfunction toIterator(_x) {\n  return _toIterator.apply(this, arguments);\n}\nfunction _toIterator() {\n  _toIterator = _wrapAsyncGenerator(function (parts) {\n    var clone = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;\n    return /*#__PURE__*/_regeneratorRuntime().mark(function _callee() {\n      var _iterator3, _step3, part, position, end, size, chunk, _position, b, _chunk, buffer;\n      return _regeneratorRuntime().wrap(function _callee$(_context) {\n        while (1) {\n          switch (_context.prev = _context.next) {\n            case 0:\n              _iterator3 = _createForOfIteratorHelper(parts);\n              _context.prev = 1;\n              _iterator3.s();\n            case 3:\n              if ((_step3 = _iterator3.n()).done) {\n                _context.next = 40;\n                break;\n              }\n              part = _step3.value;\n              if (!('stream' in part)) {\n                _context.next = 9;\n                break;\n              }\n              return _context.delegateYield(_asyncGeneratorDelegate(_asyncIterator( /** @type {AsyncIterableIterator<Uint8Array>} */part.stream()), _awaitAsyncGenerator), \"t0\", 7);\n            case 7:\n              _context.next = 38;\n              break;\n            case 9:\n              if (!ArrayBuffer.isView(part)) {\n                _context.next = 27;\n                break;\n              }\n              if (!clone) {\n                _context.next = 23;\n                break;\n              }\n              position = part.byteOffset;\n              end = part.byteOffset + part.byteLength;\n            case 13:\n              if (!(position !== end)) {\n                _context.next = 21;\n                break;\n              }\n              size = Math.min(end - position, POOL_SIZE);\n              chunk = part.buffer.slice(position, position + size);\n              position += chunk.byteLength;\n              _context.next = 19;\n              return new Uint8Array(chunk);\n            case 19:\n              _context.next = 13;\n              break;\n            case 21:\n              _context.next = 25;\n              break;\n            case 23:\n              _context.next = 25;\n              return part;\n            case 25:\n              _context.next = 38;\n              break;\n            case 27:\n              // For blobs that have arrayBuffer but no stream method (nodes buffer.Blob)\n              _position = 0, b = /** @type {Blob} */part;\n            case 28:\n              if (!(_position !== b.size)) {\n                _context.next = 38;\n                break;\n              }\n              _chunk = b.slice(_position, Math.min(b.size, _position + POOL_SIZE));\n              _context.next = 32;\n              return _awaitAsyncGenerator(_chunk.arrayBuffer());\n            case 32:\n              buffer = _context.sent;\n              _position += buffer.byteLength;\n              _context.next = 36;\n              return new Uint8Array(buffer);\n            case 36:\n              _context.next = 28;\n              break;\n            case 38:\n              _context.next = 3;\n              break;\n            case 40:\n              _context.next = 45;\n              break;\n            case 42:\n              _context.prev = 42;\n              _context.t1 = _context[\"catch\"](1);\n              _iterator3.e(_context.t1);\n            case 45:\n              _context.prev = 45;\n              _iterator3.f();\n              return _context.finish(45);\n            case 48:\n            case \"end\":\n              return _context.stop();\n          }\n        }\n      }, _callee, null, [[1, 42, 45, 48]]);\n    })();\n  });\n  return _toIterator.apply(this, arguments);\n}\nvar _Blob = (_parts = /*#__PURE__*/new WeakMap(), _type = /*#__PURE__*/new WeakMap(), _size = /*#__PURE__*/new WeakMap(), _endings = /*#__PURE__*/new WeakMap(), _Symbol$toStringTag = Symbol.toStringTag, _Symbol$hasInstance = Symbol.hasInstance, /*#__PURE__*/function () {\n  /** @type {Array.<(Blob|Uint8Array)>} */\n\n  /**\n   * The Blob() constructor returns a new Blob object. The content\n   * of the blob consists of the concatenation of the values given\n   * in the parameter array.\n   *\n   * @param {*} blobParts\n   * @param {{ type?: string, endings?: string }} [options]\n   */\n  function Blob() {\n    var blobParts = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : [];\n    var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n    _classCallCheck(this, Blob);\n    _classPrivateFieldInitSpec(this, _parts, {\n      writable: true,\n      value: []\n    });\n    _classPrivateFieldInitSpec(this, _type, {\n      writable: true,\n      value: ''\n    });\n    _classPrivateFieldInitSpec(this, _size, {\n      writable: true,\n      value: 0\n    });\n    _classPrivateFieldInitSpec(this, _endings, {\n      writable: true,\n      value: 'transparent'\n    });\n    if (typeof blobParts !== 'object' || blobParts === null) {\n      throw new TypeError('Failed to construct \\'Blob\\': The provided value cannot be converted to a sequence.');\n    }\n    if (typeof blobParts[Symbol.iterator] !== 'function') {\n      throw new TypeError('Failed to construct \\'Blob\\': The object must have a callable @@iterator property.');\n    }\n    if (typeof options !== 'object' && typeof options !== 'function') {\n      throw new TypeError('Failed to construct \\'Blob\\': parameter 2 cannot convert to dictionary.');\n    }\n    if (options === null) options = {};\n    var encoder = new TextEncoder();\n    var _iterator4 = _createForOfIteratorHelper(blobParts),\n      _step4;\n    try {\n      for (_iterator4.s(); !(_step4 = _iterator4.n()).done;) {\n        var element = _step4.value;\n        var part = void 0;\n        if (ArrayBuffer.isView(element)) {\n          part = new Uint8Array(element.buffer.slice(element.byteOffset, element.byteOffset + element.byteLength));\n        } else if (element instanceof ArrayBuffer) {\n          part = new Uint8Array(element.slice(0));\n        } else if (element instanceof Blob) {\n          part = element;\n        } else {\n          part = encoder.encode(\"\".concat(element));\n        }\n        _classPrivateFieldSet(this, _size, _classPrivateFieldGet(this, _size) + (ArrayBuffer.isView(part) ? part.byteLength : part.size));\n        _classPrivateFieldGet(this, _parts).push(part);\n      }\n    } catch (err) {\n      _iterator4.e(err);\n    } finally {\n      _iterator4.f();\n    }\n    _classPrivateFieldSet(this, _endings, \"\".concat(options.endings === undefined ? 'transparent' : options.endings));\n    var type = options.type === undefined ? '' : String(options.type);\n    _classPrivateFieldSet(this, _type, /^[\\x20-\\x7E]*$/.test(type) ? type : '');\n  }\n\n  /**\n   * The Blob interface's size property returns the\n   * size of the Blob in bytes.\n   */\n  _createClass(Blob, [{\n    key: \"size\",\n    get: function get() {\n      return _classPrivateFieldGet(this, _size);\n    }\n\n    /**\n     * The type property of a Blob object returns the MIME type of the file.\n     */\n  }, {\n    key: \"type\",\n    get: function get() {\n      return _classPrivateFieldGet(this, _type);\n    }\n\n    /**\n     * The text() method in the Blob interface returns a Promise\n     * that resolves with a string containing the contents of\n     * the blob, interpreted as UTF-8.\n     *\n     * @return {Promise<string>}\n     */\n  }, {\n    key: \"text\",\n    value: function () {\n      var _text = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee2() {\n        var decoder, str, _iteratorAbruptCompletion, _didIteratorError, _iteratorError, _iterator, _step, part;\n        return _regeneratorRuntime().wrap(function _callee2$(_context2) {\n          while (1) {\n            switch (_context2.prev = _context2.next) {\n              case 0:\n                // More optimized than using this.arrayBuffer()\n                // that requires twice as much ram\n                decoder = new TextDecoder();\n                str = '';\n                _iteratorAbruptCompletion = false;\n                _didIteratorError = false;\n                _context2.prev = 4;\n                _iterator = _asyncIterator(toIterator(_classPrivateFieldGet(this, _parts), false));\n              case 6:\n                _context2.next = 8;\n                return _iterator.next();\n              case 8:\n                if (!(_iteratorAbruptCompletion = !(_step = _context2.sent).done)) {\n                  _context2.next = 14;\n                  break;\n                }\n                part = _step.value;\n                str += decoder.decode(part, {\n                  stream: true\n                });\n              case 11:\n                _iteratorAbruptCompletion = false;\n                _context2.next = 6;\n                break;\n              case 14:\n                _context2.next = 20;\n                break;\n              case 16:\n                _context2.prev = 16;\n                _context2.t0 = _context2[\"catch\"](4);\n                _didIteratorError = true;\n                _iteratorError = _context2.t0;\n              case 20:\n                _context2.prev = 20;\n                _context2.prev = 21;\n                if (!(_iteratorAbruptCompletion && _iterator.return != null)) {\n                  _context2.next = 25;\n                  break;\n                }\n                _context2.next = 25;\n                return _iterator.return();\n              case 25:\n                _context2.prev = 25;\n                if (!_didIteratorError) {\n                  _context2.next = 28;\n                  break;\n                }\n                throw _iteratorError;\n              case 28:\n                return _context2.finish(25);\n              case 29:\n                return _context2.finish(20);\n              case 30:\n                // Remaining\n                str += decoder.decode();\n                return _context2.abrupt(\"return\", str);\n              case 32:\n              case \"end\":\n                return _context2.stop();\n            }\n          }\n        }, _callee2, this, [[4, 16, 20, 30], [21,, 25, 29]]);\n      }));\n      function text() {\n        return _text.apply(this, arguments);\n      }\n      return text;\n    }()\n    /**\n     * The arrayBuffer() method in the Blob interface returns a\n     * Promise that resolves with the contents of the blob as\n     * binary data contained in an ArrayBuffer.\n     *\n     * @return {Promise<ArrayBuffer>}\n     */\n  }, {\n    key: \"arrayBuffer\",\n    value: function () {\n      var _arrayBuffer = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee3() {\n        var data, offset, _iteratorAbruptCompletion2, _didIteratorError2, _iteratorError2, _iterator2, _step2, chunk;\n        return _regeneratorRuntime().wrap(function _callee3$(_context3) {\n          while (1) {\n            switch (_context3.prev = _context3.next) {\n              case 0:\n                // Easier way... Just a unnecessary overhead\n                // const view = new Uint8Array(this.size);\n                // await this.stream().getReader({mode: 'byob'}).read(view);\n                // return view.buffer;\n                data = new Uint8Array(this.size);\n                offset = 0;\n                _iteratorAbruptCompletion2 = false;\n                _didIteratorError2 = false;\n                _context3.prev = 4;\n                _iterator2 = _asyncIterator(toIterator(_classPrivateFieldGet(this, _parts), false));\n              case 6:\n                _context3.next = 8;\n                return _iterator2.next();\n              case 8:\n                if (!(_iteratorAbruptCompletion2 = !(_step2 = _context3.sent).done)) {\n                  _context3.next = 15;\n                  break;\n                }\n                chunk = _step2.value;\n                data.set(chunk, offset);\n                offset += chunk.length;\n              case 12:\n                _iteratorAbruptCompletion2 = false;\n                _context3.next = 6;\n                break;\n              case 15:\n                _context3.next = 21;\n                break;\n              case 17:\n                _context3.prev = 17;\n                _context3.t0 = _context3[\"catch\"](4);\n                _didIteratorError2 = true;\n                _iteratorError2 = _context3.t0;\n              case 21:\n                _context3.prev = 21;\n                _context3.prev = 22;\n                if (!(_iteratorAbruptCompletion2 && _iterator2.return != null)) {\n                  _context3.next = 26;\n                  break;\n                }\n                _context3.next = 26;\n                return _iterator2.return();\n              case 26:\n                _context3.prev = 26;\n                if (!_didIteratorError2) {\n                  _context3.next = 29;\n                  break;\n                }\n                throw _iteratorError2;\n              case 29:\n                return _context3.finish(26);\n              case 30:\n                return _context3.finish(21);\n              case 31:\n                return _context3.abrupt(\"return\", data.buffer);\n              case 32:\n              case \"end\":\n                return _context3.stop();\n            }\n          }\n        }, _callee3, this, [[4, 17, 21, 31], [22,, 26, 30]]);\n      }));\n      function arrayBuffer() {\n        return _arrayBuffer.apply(this, arguments);\n      }\n      return arrayBuffer;\n    }()\n  }, {\n    key: \"stream\",\n    value: function stream() {\n      var it = toIterator(_classPrivateFieldGet(this, _parts), true);\n      return new globalThis.ReadableStream({\n        // @ts-ignore\n        type: 'bytes',\n        pull: function pull(ctrl) {\n          return _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee4() {\n            var chunk;\n            return _regeneratorRuntime().wrap(function _callee4$(_context4) {\n              while (1) {\n                switch (_context4.prev = _context4.next) {\n                  case 0:\n                    _context4.next = 2;\n                    return it.next();\n                  case 2:\n                    chunk = _context4.sent;\n                    chunk.done ? ctrl.close() : ctrl.enqueue(chunk.value);\n                  case 4:\n                  case \"end\":\n                    return _context4.stop();\n                }\n              }\n            }, _callee4);\n          }))();\n        },\n        cancel: function cancel() {\n          return _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee5() {\n            return _regeneratorRuntime().wrap(function _callee5$(_context5) {\n              while (1) {\n                switch (_context5.prev = _context5.next) {\n                  case 0:\n                    _context5.next = 2;\n                    return it.return();\n                  case 2:\n                  case \"end\":\n                    return _context5.stop();\n                }\n              }\n            }, _callee5);\n          }))();\n        }\n      });\n    }\n\n    /**\n     * The Blob interface's slice() method creates and returns a\n     * new Blob object which contains data from a subset of the\n     * blob on which it's called.\n     *\n     * @param {number} [start]\n     * @param {number} [end]\n     * @param {string} [type]\n     */\n  }, {\n    key: \"slice\",\n    value: function slice() {\n      var start = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;\n      var end = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : this.size;\n      var type = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : '';\n      var size = this.size;\n      var relativeStart = start < 0 ? Math.max(size + start, 0) : Math.min(start, size);\n      var relativeEnd = end < 0 ? Math.max(size + end, 0) : Math.min(end, size);\n      var span = Math.max(relativeEnd - relativeStart, 0);\n      var parts = _classPrivateFieldGet(this, _parts);\n      var blobParts = [];\n      var added = 0;\n      var _iterator5 = _createForOfIteratorHelper(parts),\n        _step5;\n      try {\n        for (_iterator5.s(); !(_step5 = _iterator5.n()).done;) {\n          var part = _step5.value;\n          // don't add the overflow to new blobParts\n          if (added >= span) {\n            break;\n          }\n          var _size2 = ArrayBuffer.isView(part) ? part.byteLength : part.size;\n          if (relativeStart && _size2 <= relativeStart) {\n            // Skip the beginning and change the relative\n            // start & end position as we skip the unwanted parts\n            relativeStart -= _size2;\n            relativeEnd -= _size2;\n          } else {\n            var chunk = void 0;\n            if (ArrayBuffer.isView(part)) {\n              chunk = part.subarray(relativeStart, Math.min(_size2, relativeEnd));\n              added += chunk.byteLength;\n            } else {\n              chunk = part.slice(relativeStart, Math.min(_size2, relativeEnd));\n              added += chunk.size;\n            }\n            relativeEnd -= _size2;\n            blobParts.push(chunk);\n            relativeStart = 0; // All next sequential parts should start at 0\n          }\n        }\n      } catch (err) {\n        _iterator5.e(err);\n      } finally {\n        _iterator5.f();\n      }\n      var blob = new Blob([], {\n        type: String(type).toLowerCase()\n      });\n      _classPrivateFieldSet(blob, _size, span);\n      _classPrivateFieldSet(blob, _parts, blobParts);\n      return blob;\n    }\n  }, {\n    key: _Symbol$toStringTag,\n    get: function get() {\n      return 'Blob';\n    }\n  }], [{\n    key: _Symbol$hasInstance,\n    value: function value(object) {\n      return object && typeof object === 'object' && typeof object.constructor === 'function' && (typeof object.stream === 'function' || typeof object.arrayBuffer === 'function') && /^(Blob|File)$/.test(object[Symbol.toStringTag]);\n    }\n  }]);\n  return Blob;\n}());\nObject.defineProperties(_Blob.prototype, {\n  size: {\n    enumerable: true\n  },\n  type: {\n    enumerable: true\n  },\n  slice: {\n    enumerable: true\n  }\n});\n\n/** @type {typeof globalThis.Blob} */\nexport var Blob = _Blob;\nexport default Blob;","map":{"version":3,"names":["POOL_SIZE","toIterator","parts","clone","part","stream","ArrayBuffer","isView","position","byteOffset","end","byteLength","size","Math","min","chunk","buffer","slice","Uint8Array","b","arrayBuffer","_Blob","Symbol","toStringTag","hasInstance","blobParts","options","TypeError","iterator","encoder","TextEncoder","element","Blob","encode","push","endings","undefined","type","String","test","decoder","TextDecoder","str","decode","data","offset","set","length","it","globalThis","ReadableStream","pull","ctrl","next","done","close","enqueue","value","cancel","return","start","relativeStart","max","relativeEnd","span","added","subarray","blob","toLowerCase","object","constructor","Object","defineProperties","prototype","enumerable"],"sources":["/home/ubuntu/environment/public_html/DealTracker/front-end/node_modules/fetch-blob/index.js"],"sourcesContent":["/*! fetch-blob. MIT License. Jimmy Wärting <https://jimmy.warting.se/opensource> */\n\n// TODO (jimmywarting): in the feature use conditional loading with top level await (requires 14.x)\n// Node has recently added whatwg stream into core\n\nimport './streams.cjs'\n\n// 64 KiB (same size chrome slice theirs blob into Uint8array's)\nconst POOL_SIZE = 65536\n\n/** @param {(Blob | Uint8Array)[]} parts */\nasync function * toIterator (parts, clone = true) {\n  for (const part of parts) {\n    if ('stream' in part) {\n      yield * (/** @type {AsyncIterableIterator<Uint8Array>} */ (part.stream()))\n    } else if (ArrayBuffer.isView(part)) {\n      if (clone) {\n        let position = part.byteOffset\n        const end = part.byteOffset + part.byteLength\n        while (position !== end) {\n          const size = Math.min(end - position, POOL_SIZE)\n          const chunk = part.buffer.slice(position, position + size)\n          position += chunk.byteLength\n          yield new Uint8Array(chunk)\n        }\n      } else {\n        yield part\n      }\n    /* c8 ignore next 10 */\n    } else {\n      // For blobs that have arrayBuffer but no stream method (nodes buffer.Blob)\n      let position = 0, b = (/** @type {Blob} */ (part))\n      while (position !== b.size) {\n        const chunk = b.slice(position, Math.min(b.size, position + POOL_SIZE))\n        const buffer = await chunk.arrayBuffer()\n        position += buffer.byteLength\n        yield new Uint8Array(buffer)\n      }\n    }\n  }\n}\n\nconst _Blob = class Blob {\n  /** @type {Array.<(Blob|Uint8Array)>} */\n  #parts = []\n  #type = ''\n  #size = 0\n  #endings = 'transparent'\n\n  /**\n   * The Blob() constructor returns a new Blob object. The content\n   * of the blob consists of the concatenation of the values given\n   * in the parameter array.\n   *\n   * @param {*} blobParts\n   * @param {{ type?: string, endings?: string }} [options]\n   */\n  constructor (blobParts = [], options = {}) {\n    if (typeof blobParts !== 'object' || blobParts === null) {\n      throw new TypeError('Failed to construct \\'Blob\\': The provided value cannot be converted to a sequence.')\n    }\n\n    if (typeof blobParts[Symbol.iterator] !== 'function') {\n      throw new TypeError('Failed to construct \\'Blob\\': The object must have a callable @@iterator property.')\n    }\n\n    if (typeof options !== 'object' && typeof options !== 'function') {\n      throw new TypeError('Failed to construct \\'Blob\\': parameter 2 cannot convert to dictionary.')\n    }\n\n    if (options === null) options = {}\n\n    const encoder = new TextEncoder()\n    for (const element of blobParts) {\n      let part\n      if (ArrayBuffer.isView(element)) {\n        part = new Uint8Array(element.buffer.slice(element.byteOffset, element.byteOffset + element.byteLength))\n      } else if (element instanceof ArrayBuffer) {\n        part = new Uint8Array(element.slice(0))\n      } else if (element instanceof Blob) {\n        part = element\n      } else {\n        part = encoder.encode(`${element}`)\n      }\n\n      this.#size += ArrayBuffer.isView(part) ? part.byteLength : part.size\n      this.#parts.push(part)\n    }\n\n    this.#endings = `${options.endings === undefined ? 'transparent' : options.endings}`\n    const type = options.type === undefined ? '' : String(options.type)\n    this.#type = /^[\\x20-\\x7E]*$/.test(type) ? type : ''\n  }\n\n  /**\n   * The Blob interface's size property returns the\n   * size of the Blob in bytes.\n   */\n  get size () {\n    return this.#size\n  }\n\n  /**\n   * The type property of a Blob object returns the MIME type of the file.\n   */\n  get type () {\n    return this.#type\n  }\n\n  /**\n   * The text() method in the Blob interface returns a Promise\n   * that resolves with a string containing the contents of\n   * the blob, interpreted as UTF-8.\n   *\n   * @return {Promise<string>}\n   */\n  async text () {\n    // More optimized than using this.arrayBuffer()\n    // that requires twice as much ram\n    const decoder = new TextDecoder()\n    let str = ''\n    for await (const part of toIterator(this.#parts, false)) {\n      str += decoder.decode(part, { stream: true })\n    }\n    // Remaining\n    str += decoder.decode()\n    return str\n  }\n\n  /**\n   * The arrayBuffer() method in the Blob interface returns a\n   * Promise that resolves with the contents of the blob as\n   * binary data contained in an ArrayBuffer.\n   *\n   * @return {Promise<ArrayBuffer>}\n   */\n  async arrayBuffer () {\n    // Easier way... Just a unnecessary overhead\n    // const view = new Uint8Array(this.size);\n    // await this.stream().getReader({mode: 'byob'}).read(view);\n    // return view.buffer;\n\n    const data = new Uint8Array(this.size)\n    let offset = 0\n    for await (const chunk of toIterator(this.#parts, false)) {\n      data.set(chunk, offset)\n      offset += chunk.length\n    }\n\n    return data.buffer\n  }\n\n  stream () {\n    const it = toIterator(this.#parts, true)\n\n    return new globalThis.ReadableStream({\n      // @ts-ignore\n      type: 'bytes',\n      async pull (ctrl) {\n        const chunk = await it.next()\n        chunk.done ? ctrl.close() : ctrl.enqueue(chunk.value)\n      },\n\n      async cancel () {\n        await it.return()\n      }\n    })\n  }\n\n  /**\n   * The Blob interface's slice() method creates and returns a\n   * new Blob object which contains data from a subset of the\n   * blob on which it's called.\n   *\n   * @param {number} [start]\n   * @param {number} [end]\n   * @param {string} [type]\n   */\n  slice (start = 0, end = this.size, type = '') {\n    const { size } = this\n\n    let relativeStart = start < 0 ? Math.max(size + start, 0) : Math.min(start, size)\n    let relativeEnd = end < 0 ? Math.max(size + end, 0) : Math.min(end, size)\n\n    const span = Math.max(relativeEnd - relativeStart, 0)\n    const parts = this.#parts\n    const blobParts = []\n    let added = 0\n\n    for (const part of parts) {\n      // don't add the overflow to new blobParts\n      if (added >= span) {\n        break\n      }\n\n      const size = ArrayBuffer.isView(part) ? part.byteLength : part.size\n      if (relativeStart && size <= relativeStart) {\n        // Skip the beginning and change the relative\n        // start & end position as we skip the unwanted parts\n        relativeStart -= size\n        relativeEnd -= size\n      } else {\n        let chunk\n        if (ArrayBuffer.isView(part)) {\n          chunk = part.subarray(relativeStart, Math.min(size, relativeEnd))\n          added += chunk.byteLength\n        } else {\n          chunk = part.slice(relativeStart, Math.min(size, relativeEnd))\n          added += chunk.size\n        }\n        relativeEnd -= size\n        blobParts.push(chunk)\n        relativeStart = 0 // All next sequential parts should start at 0\n      }\n    }\n\n    const blob = new Blob([], { type: String(type).toLowerCase() })\n    blob.#size = span\n    blob.#parts = blobParts\n\n    return blob\n  }\n\n  get [Symbol.toStringTag] () {\n    return 'Blob'\n  }\n\n  static [Symbol.hasInstance] (object) {\n    return (\n      object &&\n      typeof object === 'object' &&\n      typeof object.constructor === 'function' &&\n      (\n        typeof object.stream === 'function' ||\n        typeof object.arrayBuffer === 'function'\n      ) &&\n      /^(Blob|File)$/.test(object[Symbol.toStringTag])\n    )\n  }\n}\n\nObject.defineProperties(_Blob.prototype, {\n  size: { enumerable: true },\n  type: { enumerable: true },\n  slice: { enumerable: true }\n})\n\n/** @type {typeof globalThis.Blob} */\nexport const Blob = _Blob\nexport default Blob\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}